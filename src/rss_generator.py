# src/rss_generator.py
from datetime import datetime
import xml.etree.ElementTree as ET
import os
import hashlib

class PodcastRSSGenerator:
    def __init__(self, base_url=None):
        # Use environment variable or relative paths if no base_url provided
        self.base_url = base_url or os.getenv('PODCAST_BASE_URL', '')
        self.podcast_info = {
            'title': 'Oil Field Insights Daily',
            'description': 'Your daily automated podcast for oil and gas industry news, generated by AI',
            'author': 'AI Podcast Generator',
            'email': 'noreply@example.com',
            'category': 'Business',
            'subcategory': 'Investing',
            'language': 'en-us',
            'image': f'{self.base_url}/podcast-cover.jpg' if self.base_url else 'podcast-cover.jpg'
        }
    
    def generate_rss_feed(self, episodes_dir='docs/episodes'):
        """Generate RSS feed for podcast distribution"""
        
        # Create root RSS element
        rss = ET.Element('rss', {
            'version': '2.0',
            'xmlns:itunes': 'http://www.itunes.com/dtds/podcast-1.0.dtd',
            'xmlns:content': 'http://purl.org/rss/1.0/modules/content/'
        })
        
        channel = ET.SubElement(rss, 'channel')
        
        # Add channel metadata
        ET.SubElement(channel, 'title').text = self.podcast_info['title']
        ET.SubElement(channel, 'description').text = self.podcast_info['description']
        ET.SubElement(channel, 'link').text = self.base_url
        ET.SubElement(channel, 'language').text = self.podcast_info['language']
        ET.SubElement(channel, 'copyright').text = f'Â© {datetime.now().year}'
        
        # iTunes specific metadata
        ET.SubElement(channel, 'itunes:author').text = self.podcast_info['author']
        ET.SubElement(channel, 'itunes:summary').text = self.podcast_info['description']
        ET.SubElement(channel, 'itunes:explicit').text = 'no'
        ET.SubElement(channel, 'itunes:type').text = 'episodic'
        
        # iTunes owner information
        owner = ET.SubElement(channel, 'itunes:owner')
        ET.SubElement(owner, 'itunes:name').text = 'Oil Field Insights'
        ET.SubElement(owner, 'itunes:email').text = self.podcast_info['email']
        
        # iTunes categories
        main_category = ET.SubElement(channel, 'itunes:category', {'text': self.podcast_info['category']})
        ET.SubElement(main_category, 'itunes:category', {'text': self.podcast_info['subcategory']})
        ET.SubElement(channel, 'itunes:category', {'text': 'News'})
        
        # Add image
        ET.SubElement(channel, 'itunes:image', {'href': self.podcast_info['image']})
        
        # Generator
        ET.SubElement(channel, 'generator').text = 'Oil Podcast Generator v1.0'
        
        # Add episodes
        episodes = self._get_episodes(episodes_dir)
        for episode in episodes:
            self._add_episode_to_feed(channel, episode)
        
        # Save RSS feed with proper formatting
        self._indent(rss)
        tree = ET.ElementTree(rss)
        
        with open('docs/feed.xml', 'wb') as f:
            tree.write(f, encoding='utf-8', xml_declaration=True)
        
        return 'docs/feed.xml'
    
    def _indent(self, elem, level=0):
        """Add pretty printing to XML"""
        i = "\n" + level * "  "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for elem in elem:
                self._indent(elem, level+1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i
    
    def _get_episodes(self, episodes_dir):
        """Get all episodes from directory"""
        episodes = []
        
        if os.path.exists(episodes_dir):
            for filename in sorted(os.listdir(episodes_dir), reverse=True):
                if filename.endswith('.mp3'):
                    filepath = os.path.join(episodes_dir, filename)
                    file_stats = os.stat(filepath)
                    
                    # Parse date from filename (oil_news_YYYYMMDD.mp3)
                    date_str = filename.replace('oil_news_', '').replace('.mp3', '')
                    try:
                        date = datetime.strptime(date_str, '%Y%m%d')
                    except:
                        date = datetime.now()
                    
                    episodes.append({
                        'title': f"Oil Field Insights - {date.strftime('%B %d, %Y')}",
                        'description': f"Daily oil and gas industry news for {date.strftime('%B %d, %Y')}. AI-generated podcast featuring two hosts discussing the latest developments, market trends, and industry insights.",
                        'file': filename,
                        'date': date,
                        'size': file_stats.st_size,
                        'duration': self._estimate_duration(file_stats.st_size),
                        'keywords': 'oil, gas, energy, industry, news, AI, podcast, drilling, OPEC, crude'
                    })
        
        return episodes[:50]  # Keep last 50 episodes
    
    def _add_episode_to_feed(self, channel, episode):
        """Add episode to RSS feed"""
        item = ET.SubElement(channel, 'item')
        
        ET.SubElement(item, 'title').text = episode['title']
        ET.SubElement(item, 'description').text = episode['description']
        
        # Generate unique GUID based on filename (permalink=false)
        guid_text = f"oil_podcast_{episode['date'].strftime('%Y%m%d')}"
        guid = ET.SubElement(item, 'guid', {'isPermaLink': 'false'})
        guid.text = guid_text
        
        # Publication date
        pub_date = episode['date'].strftime('%a, %d %b %Y %H:%M:%S +0000')
        ET.SubElement(item, 'pubDate').text = pub_date
        
        # Enclosure (the actual MP3 file)
        url = f"{self.base_url}/episodes/{episode['file']}" if self.base_url else f"episodes/{episode['file']}"
        ET.SubElement(item, 'enclosure', {
            'url': url,
            'type': 'audio/mpeg',
            'length': str(episode['size'])
        })
        
        # iTunes specific tags
        ET.SubElement(item, 'itunes:duration').text = episode['duration']
        ET.SubElement(item, 'itunes:explicit').text = 'no'
        ET.SubElement(item, 'itunes:keywords').text = episode['keywords']
    
    def _estimate_duration(self, file_size_bytes):
        """Estimate duration based on file size (128kbps MP3)"""
        # Rough calculation: 128kbps = 16KB/second
        # File size in KB / 16 = seconds
        seconds = file_size_bytes / (16 * 1024)
        minutes = int(seconds // 60)
        seconds = int(seconds % 60)
        return f"{minutes}:{seconds:02d}"